
from dataclasses import dataclass
from bisect import bisect_left


NO_COLOR = -1
RESIZE_FACTOR = 20
MATLAB_INDEX_FACTOR = 1


def union(list_a, list_b):
    """
    :return: the union of list_a and list_b
    """
    final_list = list(set(list_a) | set(list_b))
    return final_list


def unique(a):
    return list(set(a))


def binary_search(a, x):
    i = bisect_left(a, x)

    if i != len(a) and a[i] == x:
        return True
    else:
        return False


@dataclass
class TIdxAndData:
    Data: float = 0.0
    Index: int = -1.0

    def __lt__(self, other):
        if other.Data > self.Data:
            return True

        if other.Data < self.Data:
            return False

        return self.Index < other.Index


@dataclass
class TComponent:
    LeftEdgeIndex: int
    RightEdgeIndex: int
    MinIndex: int
    MinValue: float
    Alive: bool

    def __init__(self):
        self.LeftEdgeIndex = -1
        self.RightEdgeIndex = -1
        self.MinIndex = -1
        self.MinValue = 0.0
        self.Alive = False


@dataclass
class TPairedExtrema:
    MinIndex: int = -1
    MaxIndex: int = -1
    Persistence: float = 0.0

    def __lt__(self, other):
        if self.Persistence < other.Persistence:
            return True

        if self.Persistence > other.Persistence:
            return False

        return self.MinIndex < other.MinIndex


class Persistence1D:

    def __init__(self):
        self.Data = []
        self.SortedData = []
        self.Colors = []
        self.Components = []
        self.PairedExtrema = []
        self.TotalComponents = 0
        self.AliveComponentsVerified = False

    def run_persistence(self, input_data: list):

        self.Data = input_data
        self.initialize()

        if len(self.Data) == 0:
            return False

        self.create_index_value_vector()
        self.water_shed()
        self.sort_paired_extrema()

        return True

    @staticmethod
    def print_pairs(self, pairs: list):

        for i in range(len(pairs)):
            print(f"Persistence: {pairs[i].Persistence}\n"
                  f"Min Index: {pairs[i].MinIndex}\n"
                  f"Max Index: {pairs[i].MaxIndex}")

    def print_results(self, threshold: float, matlab_indexing: bool = False):

        if threshold < 0.0:
            print("Error. Threshold value must be greater than or equal to 0")

        if threshold == 0 and matlab_indexing is False:
            self.print_pairs(self.PairedExtrema)
        else:
            self.print_pairs(self.get_paired_extrema(threshold, matlab_indexing))

        print(f"Global minimum value: {self.get_global_minimum_value()}\n"
              f"index: {self.get_global_minimum_index(matlab_indexing)}")

        return

    def get_paired_extrema(self, threshold: float = 0.0, matlab_indexing: bool = False):

        if len(self.PairedExtrema) == 0 or threshold < 0.0:
            return [], False

        lower_bound = self.filter_by_persistence(threshold)

        if lower_bound == len(self.PairedExtrema):
            return [], False

        pairs = self.PairedExtrema[lower_bound: len(self.PairedExtrema)]

        if matlab_indexing is True:
            for obj in pairs:
                obj.MinIndex += MATLAB_INDEX_FACTOR
                obj.MaxIndex += MATLAB_INDEX_FACTOR

        return pairs, True

    def get_extrema_indices(self, threshold: float = 0.0, matlab_indexing: bool = False):
        minimum = []
        maximum = []

        if len(self.PairedExtrema) == 0 or threshold < 0.0:
            return minimum, maximum, False

        matlab_index_factor = 0

        if matlab_indexing is True:
            matlab_index_factor = MATLAB_INDEX_FACTOR

        lower_bound = self.filter_by_persistence(threshold)

        for i in range(lower_bound, len(self.PairedExtrema)):
            minimum.append(self.PairedExtrema[i].MinIndex + matlab_index_factor)
            maximum.append(self.PairedExtrema[i].MaxIndex + matlab_index_factor)

        return minimum, maximum, True

    def get_global_minimum_index(self, matlab_indexing: bool = False):

        if len(self.Components) == 0:
            return -1

        if matlab_indexing is True:
            return self.Components[0].MinIndex + 1

        return self.Components[0].MinIndex

    def get_global_minimum_value(self):

        if len(self.Components) == 0:
            return 0

        return self.Components[0].MinValue

    def merge_components(self, first_index: int, second_index: int):

        survivor_index = -1
        destroyed_index = -1

        if self.Components[first_index].MinValue < self.Components[second_index].MinValue:
            survivor_index = first_index
            destroyed_index = second_index
        elif self.Components[first_index].MinValue > self.Components[second_index].MinValue:
            survivor_index = second_index
            destroyed_index = first_index
        elif first_index < second_index:
            survivor_index = first_index
            destroyed_index = second_index
        else:
            survivor_index = second_index
            destroyed_index = first_index

        self.Components[destroyed_index].Alive = False
        self.Colors[self.Components[destroyed_index].RightEdgeIndex] = survivor_index
        self.Colors[self.Components[destroyed_index].LeftEdgeIndex] = survivor_index

        if self.Components[survivor_index].MinIndex > self.Components[destroyed_index].MinIndex:
            self.Components[survivor_index].LeftEdgeIndex = self.Components[destroyed_index].LeftEdgeIndex
        else:
            self.Components[survivor_index].RightEdgeIndex = self.Components[destroyed_index].RightEdgeIndex

    def create_paired_extrema(self, first_index: int, second_index: int):

        pair = TPairedExtrema()

        if self.Data[first_index] > self.Data[second_index]:
            pair.MaxIndex = first_index
            pair.MinIndex = second_index
        elif self.Data[second_index] > self.Data[first_index]:
            pair.MaxIndex = second_index
            pair.MinIndex = first_index
        elif first_index < second_index:
            pair.MinIndex = first_index
            pair.MaxIndex = second_index
        else:
            pair.MinIndex = second_index
            pair.MaxIndex = first_index

        pair.Persistence = self.Data[pair.MaxIndex] - self.Data[pair.MinIndex]
        self.PairedExtrema.append(pair)

    def create_component(self, min_index: int):

        comp = TComponent()
        comp.Alive = True
        comp.LeftEdgeIndex = min_index
        comp.RightEdgeIndex = min_index
        comp.MinIndex = min_index
        comp.MinValue = self.Data[min_index]

        self.Components.append(comp)
        self.Colors[min_index] = self.TotalComponents
        self.TotalComponents += 1

    def extend_component(self, component_index: int, data_index: int):

        if data_index + 1 == self.Components[component_index].LeftEdgeIndex:
            self.Components[component_index].LeftEdgeIndex = data_index
        elif data_index - 1 == self.Components[component_index].RightEdgeIndex:
            self.Components[component_index].RightEdgeIndex = data_index

        self.Colors[data_index] = component_index

    def initialize(self):

        self.SortedData = []
        self.Colors = []

        for i in range(len(self.Data)):
            self.Colors.append(NO_COLOR)

        self.Components = []
        self.PairedExtrema = []
        self.TotalComponents = 0
        self.AliveComponentsVerified = False

    def create_index_value_vector(self):

        if len(self.Data) == 0:
            return

        for i in range(len(self.Data)):
            dataidxpair = TIdxAndData()
            dataidxpair.Data = self.Data[i]
            dataidxpair.Index = int(i)

            self.SortedData.append(dataidxpair)

        self.SortedData.sort()

    def water_shed(self):

        if len(self.SortedData) == 1:
            self.create_component(0)
            return

        for j in range(len(self.SortedData)):
            i = self.SortedData[j].Index

            if i == 0:
                if self.Colors[i + 1] == NO_COLOR:
                    self.create_component(i)
                else:
                    self.extend_component(self.Colors[i + 1], i)

                continue
            elif i == len(self.Colors) - 1:
                if self.Colors[i - 1] == NO_COLOR:
                    self.create_component(i)
                else:
                    self.extend_component(self.Colors[i - 1], i)

                continue

            if self.Colors[i - 1] == NO_COLOR and self.Colors[i + 1] == NO_COLOR:
                self.create_component(i)
            elif self.Colors[i - 1] != NO_COLOR and self.Colors[i + 1] == NO_COLOR:
                self.extend_component(self.Colors[i - 1], i)
            elif self.Colors[i - 1] == NO_COLOR and self.Colors[i + 1] != NO_COLOR:
                self.extend_component(self.Colors[i + 1], i)
            elif self.Colors[i - 1] != NO_COLOR and self.Colors[i + 1] != NO_COLOR:
                leftComp = self.Colors[i - 1]
                rightComp = self.Colors[i + 1]

                if self.Components[rightComp].MinValue < self.Components[leftComp].MinValue:
                    self.create_paired_extrema(self.Components[leftComp].MinIndex, i)
                else:
                    self.create_paired_extrema(self.Components[rightComp].MinIndex, i)

                self.merge_components(leftComp, rightComp)
                self.Colors[i] = self.Colors[i - 1]

    def sort_paired_extrema(self):
        self.PairedExtrema.sort()

    def filter_by_persistence(self, threshold: float = 0):

        if threshold == 0 or threshold < 0:
            return self.PairedExtrema[0]

        search_pair = TPairedExtrema()
        search_pair.Persistence = threshold
        search_pair.MaxIndex = 0
        search_pair.MinIndex = 0

        for i, obj in enumerate(self.PairedExtrema):
            if search_pair < obj:
                return i


a = [1, 2, 1, 10, 1, 0, 1, 2, 1, 0, 2, 1, 1, 0, 2, 1, 0]
p = Persistence1D()
p.run_persistence(a)
print(p.get_paired_extrema(5.0))
